name: Create Release and Compare to Last "real" Release

on:
  workflow_dispatch:

jobs:
  create_release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      # üî¢ Generar un nuevo tag para el release
      - name: Generate new version tag
        id: generate_tag
        run: |
          new_tag="releas-v1.0.0-$(date +%Y%m%d%H%M%S)"
          echo "new_tag=$new_tag" >> $GITHUB_ENV

      # üîç Obtener el √∫ltimo release cuyo NOMBRE comience con "real"

      - name: Get last release starting with "real"
        id: get_last_real_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          page=1
          last_real_tag=""

          while true; do
            echo "Fetching page $page..."
            releases_data=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100&page=$page")

            # Si la respuesta est√° vac√≠a, terminamos
            if [[ "$releases_data" == "[]" || -z "$releases_data" ]]; then
              break
            fi

            # Buscar el release cuyo nombre comience con "real"
            last_real_release=$(echo "$releases_data" | jq -r '[.[] | select(.name | test("^real"))] | sort_by(.published_at) | last')

            # Si encontramos un release v√°lido, tomamos su tag y salimos del bucle
            if [[ "$last_real_release" != "null" ]]; then
              last_real_tag=$(echo "$last_real_release" | jq -r '.tag_name')
              break
            fi

            # Pasar a la siguiente p√°gina
            ((page++))
          done

          echo "Last real release tag: $last_real_tag"

          if [[ -z "$last_real_tag" || "$last_real_tag" == "null" ]]; then
            echo "‚ùå No previous 'real' release found. Skipping compare."
            exit 0  
          fi

          echo "last_real_tag=$last_real_tag" >> $GITHUB_ENV


      # üîç Obtener cambios entre el √∫ltimo "real" release y el nuevo
      - name: Get changes between releases
        id: get_changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          notes_url="https://api.github.com/repos/${{ github.repository }}/releases/generate-notes"
          
          notes_data=$(curl -s -X POST "$notes_url" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            -d '{
              "tag_name": "${{ env.new_tag }}",
              "target_commitish": "main",
              "previous_tag_name": "${{ env.last_real_tag }}"
            }')

          echo "$last_real_tag"
          echo "$notes_data"
          
          # Extraer los release notes generados
          release_notes=$(echo "$notes_data" | jq -r '.body')

          # Crear listas para cada categor√≠a de PRs
          feature_prs=()
          bug_prs=()
          other_prs=()

          # Extraer las l√≠neas que contienen PRs
          while IFS= read -r line; do
            pr_url=$(echo "$line" | grep -Eo 'https://github.com/.+/pull/[0-9]+')
            pr_number=$(echo "$pr_url" | grep -Eo '[0-9]+$')
            pr_title=$(echo "$line" | sed -E 's/\* (.+) by .*/\1/')

            # Obtener informaci√≥n del PR para extraer la rama y el autor
            pr_api_url="https://api.github.com/repos/${{ github.repository }}/pulls/$pr_number"
            pr_data=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "$pr_api_url")
            
            # Extraer la rama y el autor
            pr_branch=$(echo "$pr_data" | jq -r '.head.ref')
            pr_author=$(echo "$pr_data" | jq -r '.user.login')  # Extraer el autor del PR

            # Clasificar los PRs en caracter√≠sticas, bugs y otros seg√∫n el prefijo de la rama
            if [[ "$pr_branch" == test* ]]; then
              feature_prs+=("- [$pr_title]($pr_url) by @$pr_author ")
            elif [[ "$pr_branch" == fix* ]]; then
              bug_prs+=("- [$pr_title]($pr_url) by @$pr_author ")
            else
              other_prs+=("- [$pr_title]($pr_url) by @$pr_author ")
            fi
          done < <(echo "$release_notes" | grep -Eo '\* .+ by @[^ ]+ in https://github.com/.+/pull/[0-9]+')

          # Extraer el Full Changelog
          full_changelog=$(echo "$notes_data" | jq -r '.body' | grep -Eo '\*\*Full Changelog\*\*: .*')

          # Guardar las listas y el full_changelog en el entorno
          {
            echo "feature_prs<<EOF"
            for pr in "${feature_prs[@]}"; do
              echo "$pr"
            done
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "bug_prs<<EOF"
            for pr in "${bug_prs[@]}"; do
              echo "$pr"
            done
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "other_prs<<EOF"
            for pr in "${other_prs[@]}"; do
              echo "$pr"
            done
            echo "EOF"
          } >> $GITHUB_ENV

          echo "release_notes<<EOF" >> $GITHUB_ENV
          echo "$release_notes" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "full_changelog<<EOF" >> $GITHUB_ENV
          echo "$full_changelog" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Generate Release Notes
        id: generate_notes
        run: |
          release_notes=""

          # Add Features if they exist
          if [[ -n "${{ env.feature_prs }}" ]]; then
            release_notes="üöÄ **Features:**\n${{ env.feature_prs }}\n---\n"
          fi

          # Add Bugs if they exist
          if [[ -n "${{ env.bug_prs }}" ]]; then
            release_notes+="üêû **Bugs:**\n${{ env.bug_prs }}\n---\n"
          fi

          # Add Others if they exist
          if [[ -n "${{ env.other_prs }}" ]]; then
            release_notes+="üîß **Others:**\n${{ env.other_prs }}\n---\n"
          fi

          # Add Full Changelog
          release_notes+="üìú **Full Changelog:**\n${{ env.full_changelog }}"

          # Convert newlines to actual line breaks
          release_notes="${release_notes//$'\n'/\\n}"

          # Save the final release notes
          echo "release_notes=$release_notes" >> $GITHUB_ENV

      - name: Create Release with Changelog
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.new_tag }}
          release_name: Release ${{ env.new_tag }}
          body: ${{ env.release_notes }}
          draft: false
          prerelease: false

      
      # üîπ Imprimir las notas del release en la salida
      - name: Print release notes
        run: |
          echo "Release notes for the new release:"
          echo "üöÄ Features:"
          echo "${{ env.feature_prs }}"
          echo "üêû Bugs:"
          echo "${{ env.bug_prs }}"
          echo "üîß Others:"
          echo "${{ env.other_prs }}"
          echo ""
          echo "${{ env.formatted_release_notes }}"